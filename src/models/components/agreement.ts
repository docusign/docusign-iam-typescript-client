/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  AgreementLinks,
  AgreementLinks$inboundSchema,
} from "./agreementlinks.js";
import { CurrencyCode, CurrencyCode$inboundSchema } from "./currencycode.js";
import {
  CustomProperty,
  CustomProperty$inboundSchema,
} from "./customproperty.js";
import { LinkedData, LinkedData$inboundSchema } from "./linkeddata.js";
import { Party, Party$inboundSchema } from "./party.js";
import {
  ResourceMetadata,
  ResourceMetadata$inboundSchema,
} from "./resourcemetadata.js";

/**
 * Terms specifying the payment due date, based on a defined number of days or other conditions.
 */
export const PaymentTermsDueDate = {
  UnderSevenDays: "UNDER_SEVEN_DAYS",
  SevenDays: "SEVEN_DAYS",
  FifteenDays: "FIFTEEN_DAYS",
  ThirtyDays: "THIRTY_DAYS",
  FortyFiveDays: "FORTY_FIVE_DAYS",
  SixtyDays: "SIXTY_DAYS",
  NinetyDays: "NINETY_DAYS",
  OverNinetyDays: "OVER_NINETY_DAYS",
  OnReceipt: "ON_RECEIPT",
  Other: "OTHER",
  Silent: "SILENT",
} as const;
/**
 * Terms specifying the payment due date, based on a defined number of days or other conditions.
 */
export type PaymentTermsDueDate = ClosedEnum<typeof PaymentTermsDueDate>;

/**
 * "The conditions or rules written in a legal agreement. The set of possible provisions is determined by the agreement type."
 *
 * @remarks
 */
export type Provisions = {
  /**
   * Provisions related to changes in control of the assigning party
   */
  assignmentChangeOfControl?: string | null | undefined;
  /**
   * Provisions for the termination of assignment rights
   */
  assignmentTerminationRights?: string | null | undefined;
  /**
   * The type of assignment rights in the agreement (e.g., transferability)
   */
  assignmentType?: string | null | undefined;
  /**
   * A subset of ISO 8601 duration. Fractional or negative values are not supported.
   */
  confidentialityObligationPeriod?: string | null | undefined;
  /**
   * The governing law clause identifies the substantive law that will govern the rights and obligations of the parties to the agreement.
   */
  governingLaw?: string | null | undefined;
  /**
   * A jurisdiction clause expressly sets out which courts or tribunals have the power to hear a dispute which arises under the agreement.
   */
  jurisdiction?: string | null | undefined;
  /**
   * Type of non-disclosure agreement (e.g., unilateral, bilateral).
   */
  ndaType?: string | null | undefined;
  /**
   * Total annual value of the agreement.
   */
  annualAgreementValue?: number | null | undefined;
  /**
   * Currency code (e.g., USD, EUR) for the agreement's annual value.
   */
  annualAgreementValueCurrencyCode?: CurrencyCode | null | undefined;
  /**
   * Total value of the agreement.
   */
  totalAgreementValue?: number | null | undefined;
  /**
   * Currency code (e.g., USD, EUR) for the agreement's total value.
   */
  totalAgreementValueCurrencyCode?: CurrencyCode | null | undefined;
  /**
   * Terms specifying the payment due date, based on a defined number of days or other conditions.
   */
  paymentTermsDueDate: PaymentTermsDueDate;
  /**
   * Indicates if late payment fees can be charged.
   */
  canChargeLatePaymentFees?: boolean | null | undefined;
  /**
   * Percentage fee charged on late payments.
   */
  latePaymentFeePercent?: number | null | undefined;
  /**
   * Currency code for the liability cap amount.
   */
  liabilityCapCurrencyCode?: CurrencyCode | null | undefined;
  /**
   * Duration for the liability cap
   */
  liabilityCapDuration?: string | null | undefined;
  /**
   * Maximum liability cap in the agreement
   */
  liabilityCapFixedAmount?: number | null | undefined;
  /**
   * Multiplier applied to calculate the liability cap
   */
  liabilityCapMultiplier?: number | null | undefined;
  /**
   * Maximum allowed percentage increase in prices, limited between 0 and 100.
   */
  priceCapPercentIncrease?: number | null | undefined;
  /**
   * The duration of the auto-renewal period.
   */
  autoRenewalTermLength?: string | null | undefined;
  /**
   * Additional information related to the renewal process.
   */
  renewalAdditionalInfo?: string | null | undefined;
  /**
   * The period an agreement has been extended after it has been renewed.
   */
  renewalExtensionPeriod?: string | null | undefined;
  /**
   * ISO 8601 formatted date-time string. May be local (no timezone), UTC (Z suffix), or include an explicit offset (e.g., +05:30, -0800).
   */
  renewalNoticeDate?: string | undefined;
  /**
   * The period of time that a party is required to provide to indicate their intention to renew an agreement.
   */
  renewalNoticePeriod?: string | null | undefined;
  /**
   * User ID of the person responsible for managing the renewal process
   */
  renewalProcessOwner?: string | undefined;
  /**
   * Specifies the type of renewal (e.g., automatic, manual).
   */
  renewalType?: string | null | undefined;
  /**
   * The specific duration that a party has to give notice before terminating the agreement due to a significant breach or violation of terms.
   *
   * @remarks
   * This period allows the other party to address the cause or prepare for termination.
   */
  terminationPeriodForCause?: string | null | undefined;
  /**
   * Specifies the required notice period that a party must provide before terminating the agreement for convenience, without cause, under the terms outlined in the contract.
   */
  terminationPeriodForConvenience?: string | null | undefined;
  /**
   * ISO 8601 formatted date-time string. May be local (no timezone), UTC (Z suffix), or include an explicit offset (e.g., +05:30, -0800).
   */
  effectiveDate?: string | undefined;
  /**
   * ISO 8601 formatted date-time string. May be local (no timezone), UTC (Z suffix), or include an explicit offset (e.g., +05:30, -0800).
   */
  executionDate?: string | undefined;
  /**
   * ISO 8601 formatted date-time string. May be local (no timezone), UTC (Z suffix), or include an explicit offset (e.g., +05:30, -0800).
   */
  expirationDate?: string | undefined;
  /**
   * Overall duration of the agreement.
   */
  termLength?: string | null | undefined;
};

export type RelatedAgreementDocuments = {
  /**
   * ID of the parent agreement document, if related.
   */
  parentAgreementDocumentId: string;
};

/**
 * The Agreement component represents a comprehensive overview of a contractual document, detailing its unique identifiers, key properties, parties involved,
 *
 * @remarks
 * and specific provisions. It includes general information such as the title, type, status, and important dates like effective and expiration dates.
 * The component also incorporates various provisions—legal, financial, lifecycle, and custom—along with metadata, external references, and related documents
 * to offer a full representation of the structure and context of an agreement.
 */
export type Agreement = {
  /**
   * Hypermedia controls (HATEOAS) for agreement specific links to resources.
   *
   * @remarks
   */
  links?: AgreementLinks | null | undefined;
  /**
   * A generic map/dict. The key is a string, and the value can be of any type, including strings, booleans, numbers, arrays, or objects
   */
  additionalCustomClmData?: { [k: string]: CustomProperty } | null | undefined;
  /**
   * A generic map/dict. The key is a string, and the value can be of any type, including strings, booleans, numbers, arrays, or objects
   */
  additionalCustomEsignData?:
    | { [k: string]: CustomProperty }
    | null
    | undefined;
  /**
   * A generic map/dict. The key is a string, and the value can be of any type, including strings, booleans, numbers, arrays, or objects
   */
  additionalUserDefinedData?:
    | { [k: string]: CustomProperty }
    | null
    | undefined;
  /**
   * Server-defined category based on the agreement type.
   */
  category?: string | null | undefined;
  /**
   * A generic map/dict. The key is a string, and the value can be of any type, including strings, booleans, numbers, arrays, or objects
   */
  customProvisions?: { [k: string]: CustomProperty } | null | undefined;
  /**
   * The id the original agreement document.
   */
  documentId?: string | null | undefined;
  /**
   * The file name of the agreement.
   */
  fileName?: string | null | undefined;
  id: string;
  /**
   * List of languages applicable to the agreement, identified using BCP-47 language codes.
   */
  languages?: Array<string | null> | null | undefined;
  linkedData?: Array<LinkedData> | undefined;
  metadata?: ResourceMetadata | undefined;
  /**
   * A list of parties involved in the agreement.
   */
  parties?: Array<Party> | null | undefined;
  /**
   * "The conditions or rules written in a legal agreement. The set of possible provisions is determined by the agreement type."
   *
   * @remarks
   */
  provisions?: Provisions | null | undefined;
  relatedAgreementDocuments?: RelatedAgreementDocuments | undefined;
  /**
   * The date when the agreement extraction review was completed.
   */
  reviewCompletedAt?: Date | null | undefined;
  /**
   * The review status of the agreement, indicating whether it has been complete or pending.
   */
  reviewStatus?: string | null | undefined;
  /**
   * The Account ID of the source system who creates this entity, e.g. eSign Account ID
   */
  sourceAccountId?: string | null | undefined;
  /**
   * The ID of the entity in the source system that this entity is associated with. For example, it could be an ID of the envelope in eSign.
   */
  sourceId?: string | null | undefined;
  /**
   * The name of the source system which created this agreement, e.g. eSign, CLM, or Salesforce.
   */
  sourceName?: string | null | undefined;
  /**
   * Current status of the agreement (e.g., PENDING, COMPLETE, INACTIVE)
   */
  status?: string | null | undefined;
  /**
   * A detailed summary of the agreement's key provisions and scope.
   */
  summary?: string | null | undefined;
  /**
   * Title of the agreement document, summarizing its purpose.
   */
  title?: string | null | undefined;
  /**
   * The type of agreement.
   */
  type?: string | null | undefined;
};

/** @internal */
export const PaymentTermsDueDate$inboundSchema: z.ZodNativeEnum<
  typeof PaymentTermsDueDate
> = z.nativeEnum(PaymentTermsDueDate);

/** @internal */
export const Provisions$inboundSchema: z.ZodType<
  Provisions,
  z.ZodTypeDef,
  unknown
> = z.object({
  assignment_change_of_control: z.nullable(z.string()).optional(),
  assignment_termination_rights: z.nullable(z.string()).optional(),
  assignment_type: z.nullable(z.string()).optional(),
  confidentiality_obligation_period: z.nullable(z.string()).optional(),
  governing_law: z.nullable(z.string()).optional(),
  jurisdiction: z.nullable(z.string()).optional(),
  nda_type: z.nullable(z.string()).optional(),
  annual_agreement_value: z.nullable(z.number()).optional(),
  annual_agreement_value_currency_code: z.nullable(CurrencyCode$inboundSchema)
    .optional(),
  total_agreement_value: z.nullable(z.number()).optional(),
  total_agreement_value_currency_code: z.nullable(CurrencyCode$inboundSchema)
    .optional(),
  payment_terms_due_date: PaymentTermsDueDate$inboundSchema.default("OTHER"),
  can_charge_late_payment_fees: z.nullable(z.boolean()).optional(),
  late_payment_fee_percent: z.nullable(z.number()).optional(),
  liability_cap_currency_code: z.nullable(CurrencyCode$inboundSchema)
    .optional(),
  liability_cap_duration: z.nullable(z.string()).optional(),
  liability_cap_fixed_amount: z.nullable(z.number()).optional(),
  liability_cap_multiplier: z.nullable(z.number()).optional(),
  price_cap_percent_increase: z.nullable(z.number()).optional(),
  auto_renewal_term_length: z.nullable(z.string()).optional(),
  renewal_additional_info: z.nullable(z.string()).optional(),
  renewal_extension_period: z.nullable(z.string()).optional(),
  renewal_notice_date: z.string().optional(),
  renewal_notice_period: z.nullable(z.string()).optional(),
  renewal_process_owner: z.string().optional(),
  renewal_type: z.nullable(z.string()).optional(),
  termination_period_for_cause: z.nullable(z.string()).optional(),
  termination_period_for_convenience: z.nullable(z.string()).optional(),
  effective_date: z.string().optional(),
  execution_date: z.string().optional(),
  expiration_date: z.string().optional(),
  term_length: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "assignment_change_of_control": "assignmentChangeOfControl",
    "assignment_termination_rights": "assignmentTerminationRights",
    "assignment_type": "assignmentType",
    "confidentiality_obligation_period": "confidentialityObligationPeriod",
    "governing_law": "governingLaw",
    "nda_type": "ndaType",
    "annual_agreement_value": "annualAgreementValue",
    "annual_agreement_value_currency_code": "annualAgreementValueCurrencyCode",
    "total_agreement_value": "totalAgreementValue",
    "total_agreement_value_currency_code": "totalAgreementValueCurrencyCode",
    "payment_terms_due_date": "paymentTermsDueDate",
    "can_charge_late_payment_fees": "canChargeLatePaymentFees",
    "late_payment_fee_percent": "latePaymentFeePercent",
    "liability_cap_currency_code": "liabilityCapCurrencyCode",
    "liability_cap_duration": "liabilityCapDuration",
    "liability_cap_fixed_amount": "liabilityCapFixedAmount",
    "liability_cap_multiplier": "liabilityCapMultiplier",
    "price_cap_percent_increase": "priceCapPercentIncrease",
    "auto_renewal_term_length": "autoRenewalTermLength",
    "renewal_additional_info": "renewalAdditionalInfo",
    "renewal_extension_period": "renewalExtensionPeriod",
    "renewal_notice_date": "renewalNoticeDate",
    "renewal_notice_period": "renewalNoticePeriod",
    "renewal_process_owner": "renewalProcessOwner",
    "renewal_type": "renewalType",
    "termination_period_for_cause": "terminationPeriodForCause",
    "termination_period_for_convenience": "terminationPeriodForConvenience",
    "effective_date": "effectiveDate",
    "execution_date": "executionDate",
    "expiration_date": "expirationDate",
    "term_length": "termLength",
  });
});

export function provisionsFromJSON(
  jsonString: string,
): SafeParseResult<Provisions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Provisions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Provisions' from JSON`,
  );
}

/** @internal */
export const RelatedAgreementDocuments$inboundSchema: z.ZodType<
  RelatedAgreementDocuments,
  z.ZodTypeDef,
  unknown
> = z.object({
  parent_agreement_document_id: z.string().default(
    "00000000-0000-0000-0000-000000000000",
  ),
}).transform((v) => {
  return remap$(v, {
    "parent_agreement_document_id": "parentAgreementDocumentId",
  });
});

export function relatedAgreementDocumentsFromJSON(
  jsonString: string,
): SafeParseResult<RelatedAgreementDocuments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RelatedAgreementDocuments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RelatedAgreementDocuments' from JSON`,
  );
}

/** @internal */
export const Agreement$inboundSchema: z.ZodType<
  Agreement,
  z.ZodTypeDef,
  unknown
> = z.object({
  _links: z.nullable(AgreementLinks$inboundSchema).optional(),
  additional_custom_clm_data: z.nullable(z.record(CustomProperty$inboundSchema))
    .optional(),
  additional_custom_esign_data: z.nullable(
    z.record(CustomProperty$inboundSchema),
  ).optional(),
  additional_user_defined_data: z.nullable(
    z.record(CustomProperty$inboundSchema),
  ).optional(),
  category: z.nullable(z.string()).optional(),
  custom_provisions: z.nullable(z.record(CustomProperty$inboundSchema))
    .optional(),
  document_id: z.nullable(z.string()).optional(),
  file_name: z.nullable(z.string()).optional(),
  id: z.string().default("00000000-0000-0000-0000-000000000000"),
  languages: z.nullable(z.array(z.nullable(z.string()))).optional(),
  linked_data: z.array(LinkedData$inboundSchema).optional(),
  metadata: ResourceMetadata$inboundSchema.optional(),
  parties: z.nullable(z.array(Party$inboundSchema)).optional(),
  provisions: z.nullable(z.lazy(() => Provisions$inboundSchema)).optional(),
  related_agreement_documents: z.lazy(() =>
    RelatedAgreementDocuments$inboundSchema
  ).optional(),
  review_completed_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  review_status: z.nullable(z.string()).optional(),
  source_account_id: z.nullable(z.string()).optional(),
  source_id: z.nullable(z.string()).optional(),
  source_name: z.nullable(z.string()).optional(),
  status: z.nullable(z.string()).optional(),
  summary: z.nullable(z.string()).optional(),
  title: z.nullable(z.string()).optional(),
  type: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "_links": "links",
    "additional_custom_clm_data": "additionalCustomClmData",
    "additional_custom_esign_data": "additionalCustomEsignData",
    "additional_user_defined_data": "additionalUserDefinedData",
    "custom_provisions": "customProvisions",
    "document_id": "documentId",
    "file_name": "fileName",
    "linked_data": "linkedData",
    "related_agreement_documents": "relatedAgreementDocuments",
    "review_completed_at": "reviewCompletedAt",
    "review_status": "reviewStatus",
    "source_account_id": "sourceAccountId",
    "source_id": "sourceId",
    "source_name": "sourceName",
  });
});

export function agreementFromJSON(
  jsonString: string,
): SafeParseResult<Agreement, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Agreement$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Agreement' from JSON`,
  );
}
