/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  CurrencyCode,
  CurrencyCode$inboundSchema,
  CurrencyCode$outboundSchema,
} from "./currencycode.js";
import {
  CustomProperty,
  CustomProperty$inboundSchema,
  CustomProperty$Outbound,
  CustomProperty$outboundSchema,
} from "./customproperty.js";
import {
  Party,
  Party$inboundSchema,
  Party$Outbound,
  Party$outboundSchema,
} from "./party.js";
import {
  ResourceMetadata,
  ResourceMetadata$inboundSchema,
  ResourceMetadata$Outbound,
  ResourceMetadata$outboundSchema,
} from "./resourcemetadata.js";

/**
 * Terms specifying the payment due date, based on a defined number of days or other conditions.
 */
export const PaymentTermsDueDate = {
  UnderSevenDays: "UNDER_SEVEN_DAYS",
  SevenDays: "SEVEN_DAYS",
  FifteenDays: "FIFTEEN_DAYS",
  ThirtyDays: "THIRTY_DAYS",
  FortyFiveDays: "FORTY_FIVE_DAYS",
  SixtyDays: "SIXTY_DAYS",
  NinetyDays: "NINETY_DAYS",
  OverNinetyDays: "OVER_NINETY_DAYS",
  OnReceipt: "ON_RECEIPT",
  Other: "OTHER",
  Silent: "SILENT",
} as const;
/**
 * Terms specifying the payment due date, based on a defined number of days or other conditions.
 */
export type PaymentTermsDueDate = ClosedEnum<typeof PaymentTermsDueDate>;

/**
 * "The conditions or rules written in a legal agreement. The set of possible provisions is determined by the agreement type."
 *
 * @remarks
 */
export type Provisions = {
  /**
   * The type of assignment rights in the agreement (e.g., transferability)
   */
  assignmentType?: string | undefined;
  /**
   * Provisions related to changes in control of the assigning party
   */
  assignmentChangeOfControl?: string | undefined;
  /**
   * Provisions for the termination of assignment rights
   */
  assignmentTerminationRights?: string | undefined;
  /**
   * A subset of ISO 8601 duration. Fractional or negative values are not supported.
   */
  confidentialityObligationPeriod?: string | null | undefined;
  /**
   * The governing law clause identifies the substantive law that will govern the rights and obligations of the parties to the agreement.
   */
  governingLaw?: string | null | undefined;
  /**
   * A jurisdiction clause expressly sets out which courts or tribunals have the power to hear a dispute which arises under the agreement.
   */
  jurisdiction?: string | null | undefined;
  /**
   * Type of non-disclosure agreement (e.g., unilateral, bilateral).
   */
  ndaType?: string | null | undefined;
  /**
   * Total annual value of the agreement.
   */
  annualAgreementValue?: number | null | undefined;
  /**
   * 'ISO 4217 codes. From https://en.wikipedia.org/wiki/ISO_4217
   *
   * @remarks
   * https://www.currency-iso.org/en/home/tables/table-a1.html'
   */
  annualAgreementValueCurrencyCode?: CurrencyCode | null | undefined;
  /**
   * Total value of the agreement.
   */
  totalAgreementValue?: number | null | undefined;
  /**
   * 'ISO 4217 codes. From https://en.wikipedia.org/wiki/ISO_4217
   *
   * @remarks
   * https://www.currency-iso.org/en/home/tables/table-a1.html'
   */
  totalAgreementValueCurrencyCode?: CurrencyCode | null | undefined;
  /**
   * Terms specifying the payment due date, based on a defined number of days or other conditions.
   */
  paymentTermsDueDate?: PaymentTermsDueDate | undefined;
  /**
   * Indicates if late payment fees can be charged.
   */
  canChargeLatePaymentFees?: boolean | null | undefined;
  /**
   * Percentage fee charged on late payments.
   */
  latePaymentFeePercent?: number | null | undefined;
  /**
   * Maximum liability cap in the agreement
   */
  liabilityCapFixedAmount?: number | null | undefined;
  /**
   * 'ISO 4217 codes. From https://en.wikipedia.org/wiki/ISO_4217
   *
   * @remarks
   * https://www.currency-iso.org/en/home/tables/table-a1.html'
   */
  liabilityCapCurrencyCode?: CurrencyCode | null | undefined;
  /**
   * Multiplier applied to calculate the liability cap
   */
  liabilityCapMultiplier?: number | null | undefined;
  liabilityCapDuration?: string | null | undefined;
  /**
   * Maximum allowed percentage increase in prices, limited between 0 and 100.
   */
  priceCapPercentIncrease?: number | null | undefined;
  /**
   * Specifies the type of renewal (e.g., automatic, manual).
   */
  renewalType?: string | null | undefined;
  renewalNoticePeriod?: string | null | undefined;
  /**
   * Calculated field based on renewal notice period. (agreement expiration date - renewal notice period duration)
   */
  renewalNoticeDate?: Date | null | undefined;
  autoRenewalTermLength?: string | null | undefined;
  renewalExtensionPeriod?: string | null | undefined;
  renewalProcessOwner?: string | undefined;
  /**
   * Additional information related to the renewal process.
   */
  renewalAdditionalInfo?: string | null | undefined;
  /**
   * The specific duration that a party has to give notice before terminating the agreement due to a significant breach or violation of terms.
   *
   * @remarks
   * This period allows the other party to address the cause or prepare for termination.
   */
  terminationPeriodForCause?: string | null | undefined;
  /**
   * Specifies the required notice period that a party must provide before terminating the agreement for convenience, without cause, under the terms outlined in the contract.
   */
  terminationPeriodForConvenience?: string | null | undefined;
  /**
   * The date when the terms of the agreement start to apply and become legally binding.
   */
  effectiveDate?: Date | null | undefined;
  /**
   * The date when the agreement ends and is no longer valid or enforceable.
   */
  expirationDate?: Date | null | undefined;
  /**
   * The date when the agreement is signed by all parties, making it officially binding. This is not necessarily the same as the effective date.
   */
  executionDate?: Date | null | undefined;
  /**
   * Overall duration of the agreement.
   */
  termLength?: string | null | undefined;
};

export type RelatedAgreementDocuments = {
  parentAgreementDocumentId?: string | undefined;
};

/**
 * The Agreement component represents a comprehensive overview of a contractual document, detailing its unique identifiers, key properties, parties involved,
 *
 * @remarks
 * and specific provisions. It includes general information such as the title, type, status, and important dates like effective and expiration dates.
 * The component also incorporates various provisions—legal, financial, lifecycle, and custom—along with metadata, external references, and related documents
 * to offer a full representation of the structure and context of an agreement.
 */
export type Agreement = {
  id: string;
  /**
   * Title of the agreement document, summarizing its purpose.
   */
  title?: string | null | undefined;
  /**
   * The file name of the agreement.
   */
  fileName?: string | null | undefined;
  /**
   * The type of agreement.
   */
  type?: string | null | undefined;
  /**
   * Server-defined category based on the agreement type.
   */
  category?: string | null | undefined;
  /**
   * A detailed summary of the agreement's key provisions and scope.
   */
  summary?: string | null | undefined;
  /**
   * Current status of the agreement (e.g., PENDING, COMPLETE, INACTIVE)
   */
  status?: string | null | undefined;
  /**
   * A list of parties involved in the agreement.
   */
  parties?: Array<Party> | null | undefined;
  /**
   * "The conditions or rules written in a legal agreement. The set of possible provisions is determined by the agreement type."
   *
   * @remarks
   */
  provisions?: Provisions | null | undefined;
  /**
   * A generic map/dict. The key is a string, and the value can be of any type, including strings, booleans, numbers, arrays, or objects
   */
  customProvisions?: { [k: string]: CustomProperty } | null | undefined;
  /**
   * A generic map/dict. The key is a string, and the value can be of any type, including strings, booleans, numbers, arrays, or objects
   */
  additionalUserDefinedData?:
    | { [k: string]: CustomProperty }
    | null
    | undefined;
  /**
   * A generic map/dict. The key is a string, and the value can be of any type, including strings, booleans, numbers, arrays, or objects
   */
  additionalCustomClmData?: { [k: string]: CustomProperty } | null | undefined;
  /**
   * A generic map/dict. The key is a string, and the value can be of any type, including strings, booleans, numbers, arrays, or objects
   */
  additionalCustomEsignData?:
    | { [k: string]: CustomProperty }
    | null
    | undefined;
  relatedAgreementDocuments?: RelatedAgreementDocuments | undefined;
  /**
   * List of languages applicable to the agreement, identified using BCP-47 language codes.
   */
  languages?: Array<string | null> | null | undefined;
  /**
   * The name of the source system who creates this entity, e.g. eSign, CLM, or Salesforce.
   */
  sourceName?: string | null | undefined;
  /**
   * The ID of the entity in the source system that this entity is associated with. For example, it could be an ID of the envelope in eSign.
   */
  sourceId?: string | null | undefined;
  /**
   * The Account ID of the source system who creates this entity, e.g. eSign Account ID
   */
  sourceAccountId?: string | null | undefined;
  metadata?: ResourceMetadata | undefined;
};

/** @internal */
export const PaymentTermsDueDate$inboundSchema: z.ZodNativeEnum<
  typeof PaymentTermsDueDate
> = z.nativeEnum(PaymentTermsDueDate);

/** @internal */
export const PaymentTermsDueDate$outboundSchema: z.ZodNativeEnum<
  typeof PaymentTermsDueDate
> = PaymentTermsDueDate$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PaymentTermsDueDate$ {
  /** @deprecated use `PaymentTermsDueDate$inboundSchema` instead. */
  export const inboundSchema = PaymentTermsDueDate$inboundSchema;
  /** @deprecated use `PaymentTermsDueDate$outboundSchema` instead. */
  export const outboundSchema = PaymentTermsDueDate$outboundSchema;
}

/** @internal */
export const Provisions$inboundSchema: z.ZodType<
  Provisions,
  z.ZodTypeDef,
  unknown
> = z.object({
  assignment_type: z.string().optional(),
  assignment_change_of_control: z.string().optional(),
  assignment_termination_rights: z.string().optional(),
  confidentiality_obligation_period: z.nullable(z.string()).optional(),
  governing_law: z.nullable(z.string()).optional(),
  jurisdiction: z.nullable(z.string()).optional(),
  nda_type: z.nullable(z.string()).optional(),
  annual_agreement_value: z.nullable(z.number()).optional(),
  annual_agreement_value_currency_code: z.nullable(CurrencyCode$inboundSchema)
    .optional(),
  total_agreement_value: z.nullable(z.number()).optional(),
  total_agreement_value_currency_code: z.nullable(CurrencyCode$inboundSchema)
    .optional(),
  payment_terms_due_date: PaymentTermsDueDate$inboundSchema.default("OTHER"),
  can_charge_late_payment_fees: z.nullable(z.boolean()).optional(),
  late_payment_fee_percent: z.nullable(z.number().int()).optional(),
  liability_cap_fixed_amount: z.nullable(z.number()).optional(),
  liability_cap_currency_code: z.nullable(CurrencyCode$inboundSchema)
    .optional(),
  liability_cap_multiplier: z.nullable(z.number()).optional(),
  liability_cap_duration: z.nullable(z.string()).optional(),
  price_cap_percent_increase: z.nullable(z.number()).optional(),
  renewal_type: z.nullable(z.string()).optional(),
  renewal_notice_period: z.nullable(z.string()).optional(),
  renewal_notice_date: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  auto_renewal_term_length: z.nullable(z.string()).optional(),
  renewal_extension_period: z.nullable(z.string()).optional(),
  renewal_process_owner: z.string().optional(),
  renewal_additional_info: z.nullable(z.string()).optional(),
  termination_period_for_cause: z.nullable(z.string()).optional(),
  termination_period_for_convenience: z.nullable(z.string()).optional(),
  effective_date: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  expiration_date: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  execution_date: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  term_length: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "assignment_type": "assignmentType",
    "assignment_change_of_control": "assignmentChangeOfControl",
    "assignment_termination_rights": "assignmentTerminationRights",
    "confidentiality_obligation_period": "confidentialityObligationPeriod",
    "governing_law": "governingLaw",
    "nda_type": "ndaType",
    "annual_agreement_value": "annualAgreementValue",
    "annual_agreement_value_currency_code": "annualAgreementValueCurrencyCode",
    "total_agreement_value": "totalAgreementValue",
    "total_agreement_value_currency_code": "totalAgreementValueCurrencyCode",
    "payment_terms_due_date": "paymentTermsDueDate",
    "can_charge_late_payment_fees": "canChargeLatePaymentFees",
    "late_payment_fee_percent": "latePaymentFeePercent",
    "liability_cap_fixed_amount": "liabilityCapFixedAmount",
    "liability_cap_currency_code": "liabilityCapCurrencyCode",
    "liability_cap_multiplier": "liabilityCapMultiplier",
    "liability_cap_duration": "liabilityCapDuration",
    "price_cap_percent_increase": "priceCapPercentIncrease",
    "renewal_type": "renewalType",
    "renewal_notice_period": "renewalNoticePeriod",
    "renewal_notice_date": "renewalNoticeDate",
    "auto_renewal_term_length": "autoRenewalTermLength",
    "renewal_extension_period": "renewalExtensionPeriod",
    "renewal_process_owner": "renewalProcessOwner",
    "renewal_additional_info": "renewalAdditionalInfo",
    "termination_period_for_cause": "terminationPeriodForCause",
    "termination_period_for_convenience": "terminationPeriodForConvenience",
    "effective_date": "effectiveDate",
    "expiration_date": "expirationDate",
    "execution_date": "executionDate",
    "term_length": "termLength",
  });
});

/** @internal */
export type Provisions$Outbound = {
  assignment_type?: string | undefined;
  assignment_change_of_control?: string | undefined;
  assignment_termination_rights?: string | undefined;
  confidentiality_obligation_period?: string | null | undefined;
  governing_law?: string | null | undefined;
  jurisdiction?: string | null | undefined;
  nda_type?: string | null | undefined;
  annual_agreement_value?: number | null | undefined;
  annual_agreement_value_currency_code?: string | null | undefined;
  total_agreement_value?: number | null | undefined;
  total_agreement_value_currency_code?: string | null | undefined;
  payment_terms_due_date: string;
  can_charge_late_payment_fees?: boolean | null | undefined;
  late_payment_fee_percent?: number | null | undefined;
  liability_cap_fixed_amount?: number | null | undefined;
  liability_cap_currency_code?: string | null | undefined;
  liability_cap_multiplier?: number | null | undefined;
  liability_cap_duration?: string | null | undefined;
  price_cap_percent_increase?: number | null | undefined;
  renewal_type?: string | null | undefined;
  renewal_notice_period?: string | null | undefined;
  renewal_notice_date?: string | null | undefined;
  auto_renewal_term_length?: string | null | undefined;
  renewal_extension_period?: string | null | undefined;
  renewal_process_owner?: string | undefined;
  renewal_additional_info?: string | null | undefined;
  termination_period_for_cause?: string | null | undefined;
  termination_period_for_convenience?: string | null | undefined;
  effective_date?: string | null | undefined;
  expiration_date?: string | null | undefined;
  execution_date?: string | null | undefined;
  term_length?: string | null | undefined;
};

/** @internal */
export const Provisions$outboundSchema: z.ZodType<
  Provisions$Outbound,
  z.ZodTypeDef,
  Provisions
> = z.object({
  assignmentType: z.string().optional(),
  assignmentChangeOfControl: z.string().optional(),
  assignmentTerminationRights: z.string().optional(),
  confidentialityObligationPeriod: z.nullable(z.string()).optional(),
  governingLaw: z.nullable(z.string()).optional(),
  jurisdiction: z.nullable(z.string()).optional(),
  ndaType: z.nullable(z.string()).optional(),
  annualAgreementValue: z.nullable(z.number()).optional(),
  annualAgreementValueCurrencyCode: z.nullable(CurrencyCode$outboundSchema)
    .optional(),
  totalAgreementValue: z.nullable(z.number()).optional(),
  totalAgreementValueCurrencyCode: z.nullable(CurrencyCode$outboundSchema)
    .optional(),
  paymentTermsDueDate: PaymentTermsDueDate$outboundSchema.default("OTHER"),
  canChargeLatePaymentFees: z.nullable(z.boolean()).optional(),
  latePaymentFeePercent: z.nullable(z.number().int()).optional(),
  liabilityCapFixedAmount: z.nullable(z.number()).optional(),
  liabilityCapCurrencyCode: z.nullable(CurrencyCode$outboundSchema).optional(),
  liabilityCapMultiplier: z.nullable(z.number()).optional(),
  liabilityCapDuration: z.nullable(z.string()).optional(),
  priceCapPercentIncrease: z.nullable(z.number()).optional(),
  renewalType: z.nullable(z.string()).optional(),
  renewalNoticePeriod: z.nullable(z.string()).optional(),
  renewalNoticeDate: z.nullable(z.date().transform(v => v.toISOString()))
    .optional(),
  autoRenewalTermLength: z.nullable(z.string()).optional(),
  renewalExtensionPeriod: z.nullable(z.string()).optional(),
  renewalProcessOwner: z.string().optional(),
  renewalAdditionalInfo: z.nullable(z.string()).optional(),
  terminationPeriodForCause: z.nullable(z.string()).optional(),
  terminationPeriodForConvenience: z.nullable(z.string()).optional(),
  effectiveDate: z.nullable(z.date().transform(v => v.toISOString()))
    .optional(),
  expirationDate: z.nullable(z.date().transform(v => v.toISOString()))
    .optional(),
  executionDate: z.nullable(z.date().transform(v => v.toISOString()))
    .optional(),
  termLength: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    assignmentType: "assignment_type",
    assignmentChangeOfControl: "assignment_change_of_control",
    assignmentTerminationRights: "assignment_termination_rights",
    confidentialityObligationPeriod: "confidentiality_obligation_period",
    governingLaw: "governing_law",
    ndaType: "nda_type",
    annualAgreementValue: "annual_agreement_value",
    annualAgreementValueCurrencyCode: "annual_agreement_value_currency_code",
    totalAgreementValue: "total_agreement_value",
    totalAgreementValueCurrencyCode: "total_agreement_value_currency_code",
    paymentTermsDueDate: "payment_terms_due_date",
    canChargeLatePaymentFees: "can_charge_late_payment_fees",
    latePaymentFeePercent: "late_payment_fee_percent",
    liabilityCapFixedAmount: "liability_cap_fixed_amount",
    liabilityCapCurrencyCode: "liability_cap_currency_code",
    liabilityCapMultiplier: "liability_cap_multiplier",
    liabilityCapDuration: "liability_cap_duration",
    priceCapPercentIncrease: "price_cap_percent_increase",
    renewalType: "renewal_type",
    renewalNoticePeriod: "renewal_notice_period",
    renewalNoticeDate: "renewal_notice_date",
    autoRenewalTermLength: "auto_renewal_term_length",
    renewalExtensionPeriod: "renewal_extension_period",
    renewalProcessOwner: "renewal_process_owner",
    renewalAdditionalInfo: "renewal_additional_info",
    terminationPeriodForCause: "termination_period_for_cause",
    terminationPeriodForConvenience: "termination_period_for_convenience",
    effectiveDate: "effective_date",
    expirationDate: "expiration_date",
    executionDate: "execution_date",
    termLength: "term_length",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Provisions$ {
  /** @deprecated use `Provisions$inboundSchema` instead. */
  export const inboundSchema = Provisions$inboundSchema;
  /** @deprecated use `Provisions$outboundSchema` instead. */
  export const outboundSchema = Provisions$outboundSchema;
  /** @deprecated use `Provisions$Outbound` instead. */
  export type Outbound = Provisions$Outbound;
}

export function provisionsToJSON(provisions: Provisions): string {
  return JSON.stringify(Provisions$outboundSchema.parse(provisions));
}

export function provisionsFromJSON(
  jsonString: string,
): SafeParseResult<Provisions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Provisions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Provisions' from JSON`,
  );
}

/** @internal */
export const RelatedAgreementDocuments$inboundSchema: z.ZodType<
  RelatedAgreementDocuments,
  z.ZodTypeDef,
  unknown
> = z.object({
  parent_agreement_document_id: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "parent_agreement_document_id": "parentAgreementDocumentId",
  });
});

/** @internal */
export type RelatedAgreementDocuments$Outbound = {
  parent_agreement_document_id?: string | undefined;
};

/** @internal */
export const RelatedAgreementDocuments$outboundSchema: z.ZodType<
  RelatedAgreementDocuments$Outbound,
  z.ZodTypeDef,
  RelatedAgreementDocuments
> = z.object({
  parentAgreementDocumentId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    parentAgreementDocumentId: "parent_agreement_document_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RelatedAgreementDocuments$ {
  /** @deprecated use `RelatedAgreementDocuments$inboundSchema` instead. */
  export const inboundSchema = RelatedAgreementDocuments$inboundSchema;
  /** @deprecated use `RelatedAgreementDocuments$outboundSchema` instead. */
  export const outboundSchema = RelatedAgreementDocuments$outboundSchema;
  /** @deprecated use `RelatedAgreementDocuments$Outbound` instead. */
  export type Outbound = RelatedAgreementDocuments$Outbound;
}

export function relatedAgreementDocumentsToJSON(
  relatedAgreementDocuments: RelatedAgreementDocuments,
): string {
  return JSON.stringify(
    RelatedAgreementDocuments$outboundSchema.parse(relatedAgreementDocuments),
  );
}

export function relatedAgreementDocumentsFromJSON(
  jsonString: string,
): SafeParseResult<RelatedAgreementDocuments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RelatedAgreementDocuments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RelatedAgreementDocuments' from JSON`,
  );
}

/** @internal */
export const Agreement$inboundSchema: z.ZodType<
  Agreement,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  title: z.nullable(z.string()).optional(),
  file_name: z.nullable(z.string()).optional(),
  type: z.nullable(z.string()).optional(),
  category: z.nullable(z.string()).optional(),
  summary: z.nullable(z.string()).optional(),
  status: z.nullable(z.string()).optional(),
  parties: z.nullable(z.array(Party$inboundSchema)).optional(),
  provisions: z.nullable(z.lazy(() => Provisions$inboundSchema)).optional(),
  custom_provisions: z.nullable(z.record(CustomProperty$inboundSchema))
    .optional(),
  additional_user_defined_data: z.nullable(
    z.record(CustomProperty$inboundSchema),
  ).optional(),
  additional_custom_clm_data: z.nullable(z.record(CustomProperty$inboundSchema))
    .optional(),
  additional_custom_esign_data: z.nullable(
    z.record(CustomProperty$inboundSchema),
  ).optional(),
  related_agreement_documents: z.lazy(() =>
    RelatedAgreementDocuments$inboundSchema
  ).optional(),
  languages: z.nullable(z.array(z.nullable(z.string()))).optional(),
  source_name: z.nullable(z.string()).optional(),
  source_id: z.nullable(z.string()).optional(),
  source_account_id: z.nullable(z.string()).optional(),
  metadata: ResourceMetadata$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "file_name": "fileName",
    "custom_provisions": "customProvisions",
    "additional_user_defined_data": "additionalUserDefinedData",
    "additional_custom_clm_data": "additionalCustomClmData",
    "additional_custom_esign_data": "additionalCustomEsignData",
    "related_agreement_documents": "relatedAgreementDocuments",
    "source_name": "sourceName",
    "source_id": "sourceId",
    "source_account_id": "sourceAccountId",
  });
});

/** @internal */
export type Agreement$Outbound = {
  id: string;
  title?: string | null | undefined;
  file_name?: string | null | undefined;
  type?: string | null | undefined;
  category?: string | null | undefined;
  summary?: string | null | undefined;
  status?: string | null | undefined;
  parties?: Array<Party$Outbound> | null | undefined;
  provisions?: Provisions$Outbound | null | undefined;
  custom_provisions?:
    | { [k: string]: CustomProperty$Outbound }
    | null
    | undefined;
  additional_user_defined_data?:
    | { [k: string]: CustomProperty$Outbound }
    | null
    | undefined;
  additional_custom_clm_data?:
    | { [k: string]: CustomProperty$Outbound }
    | null
    | undefined;
  additional_custom_esign_data?:
    | { [k: string]: CustomProperty$Outbound }
    | null
    | undefined;
  related_agreement_documents?: RelatedAgreementDocuments$Outbound | undefined;
  languages?: Array<string | null> | null | undefined;
  source_name?: string | null | undefined;
  source_id?: string | null | undefined;
  source_account_id?: string | null | undefined;
  metadata?: ResourceMetadata$Outbound | undefined;
};

/** @internal */
export const Agreement$outboundSchema: z.ZodType<
  Agreement$Outbound,
  z.ZodTypeDef,
  Agreement
> = z.object({
  id: z.string(),
  title: z.nullable(z.string()).optional(),
  fileName: z.nullable(z.string()).optional(),
  type: z.nullable(z.string()).optional(),
  category: z.nullable(z.string()).optional(),
  summary: z.nullable(z.string()).optional(),
  status: z.nullable(z.string()).optional(),
  parties: z.nullable(z.array(Party$outboundSchema)).optional(),
  provisions: z.nullable(z.lazy(() => Provisions$outboundSchema)).optional(),
  customProvisions: z.nullable(z.record(CustomProperty$outboundSchema))
    .optional(),
  additionalUserDefinedData: z.nullable(z.record(CustomProperty$outboundSchema))
    .optional(),
  additionalCustomClmData: z.nullable(z.record(CustomProperty$outboundSchema))
    .optional(),
  additionalCustomEsignData: z.nullable(z.record(CustomProperty$outboundSchema))
    .optional(),
  relatedAgreementDocuments: z.lazy(() =>
    RelatedAgreementDocuments$outboundSchema
  ).optional(),
  languages: z.nullable(z.array(z.nullable(z.string()))).optional(),
  sourceName: z.nullable(z.string()).optional(),
  sourceId: z.nullable(z.string()).optional(),
  sourceAccountId: z.nullable(z.string()).optional(),
  metadata: ResourceMetadata$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    fileName: "file_name",
    customProvisions: "custom_provisions",
    additionalUserDefinedData: "additional_user_defined_data",
    additionalCustomClmData: "additional_custom_clm_data",
    additionalCustomEsignData: "additional_custom_esign_data",
    relatedAgreementDocuments: "related_agreement_documents",
    sourceName: "source_name",
    sourceId: "source_id",
    sourceAccountId: "source_account_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Agreement$ {
  /** @deprecated use `Agreement$inboundSchema` instead. */
  export const inboundSchema = Agreement$inboundSchema;
  /** @deprecated use `Agreement$outboundSchema` instead. */
  export const outboundSchema = Agreement$outboundSchema;
  /** @deprecated use `Agreement$Outbound` instead. */
  export type Outbound = Agreement$Outbound;
}

export function agreementToJSON(agreement: Agreement): string {
  return JSON.stringify(Agreement$outboundSchema.parse(agreement));
}

export function agreementFromJSON(
  jsonString: string,
): SafeParseResult<Agreement, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Agreement$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Agreement' from JSON`,
  );
}
